# -*- coding: utf-8 -*-
"""Datos solares 2023.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1MK_BFeLzIXBNJkF9jGM7qB1Y3AI20jGR

#Librerias
"""
print('hola')
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from scipy.stats import zscore
from scipy import stats
import seaborn as sn
from statsmodels.tsa.seasonal import seasonal_decompose
import matplotlib.dates as mdates
from sklearn.experimental import enable_iterative_imputer
from sklearn.impute import IterativeImputer
from sklearn.ensemble import RandomForestRegressor
from sklearn.impute import KNNImputer
import missingno as msno

"""#Formación del Data Set"""

from google.colab import drive
drive.mount('/content/drive')

"""##Solar

###Data Set Real Solar
"""

#rutas Generación Real
ruta1= '/content/drive/MyDrive/CEN/2023/Solar/GenSolarEne23/RealSolar - ENE23.xlsx'
ruta2= '/content/drive/MyDrive/CEN/2023/Solar/GenSolarFeb23/RealSolar - FEB23.xlsx'
ruta3= '/content/drive/MyDrive/CEN/2023/Solar/GenSolarMar23/RealSolar - MAR23.xlsx'
ruta4= '/content/drive/MyDrive/CEN/2023/Solar/GenSolarAbr23/RealSolar - ABR23.xlsx'
ruta5= '/content/drive/MyDrive/CEN/2023/Solar/GenSolarMay23/RealSolar - MAY23.xlsx'
ruta6= '/content/drive/MyDrive/CEN/2023/Solar/GenSolarJun23/RealSolar - JUN23.xlsx'
ruta7= '/content/drive/MyDrive/CEN/2023/Solar/GenSolarJul23/RealSolar - JUL23.xlsx'
ruta8= '/content/drive/MyDrive/CEN/2023/Solar/GenSolarAgo23/RealSolar - AGO23.xlsx'
ruta9= '/content/drive/MyDrive/CEN/2023/Solar/GenSolarSep23/RealSolar - SEP23.xlsx'
ruta10= '/content/drive/MyDrive/CEN/2023/Solar/GenSolarOct23/RealSolar - OCT23.xlsx'
ruta11= '/content/drive/MyDrive/CEN/2023/Solar/GenSolarNov23/RealSolar - NOV23.xlsx'
ruta12= '/content/drive/MyDrive/CEN/2023/Solar/GenSolarDic23/RealSolar - DIC23.xlsx'

#Definición de dataframes
df1 = pd.read_excel(ruta1, engine='openpyxl')
df2 = pd.read_excel(ruta2, engine='openpyxl')
df3 = pd.read_excel(ruta3, engine='openpyxl')
df4 = pd.read_excel(ruta4, engine='openpyxl')
df5 = pd.read_excel(ruta5, engine='openpyxl')
df6 = pd.read_excel(ruta6, engine='openpyxl')
df7 = pd.read_excel(ruta7, engine='openpyxl')
df8 = pd.read_excel(ruta8, engine='openpyxl')
df9 = pd.read_excel(ruta9, engine='openpyxl')
df10 = pd.read_excel(ruta10, engine='openpyxl')
df11 = pd.read_excel(ruta11, engine='openpyxl')
df12 = pd.read_excel(ruta12, engine='openpyxl')

merged_df = pd.concat([df1, df2, df3, df4, df5, df6, df7, df8, df9, df10, df11, df12], ignore_index=True)
data = merged_df

# Primero, convertimos la columna 'fecha' a datetime y 'hora' a string para manejar el caso de '24'
data['fecha'] = pd.to_datetime(data['Fecha'])
data['hora'] = data['Hora'].astype(str)

# Manejar el caso especial de la hora '24'
data.loc[data['hora'] == '24', 'fecha'] += pd.Timedelta(days=1)
data.loc[data['hora'] == '24', 'hora'] = '00'

# Ahora, combinar las columnas 'fecha' y 'hora' en una nueva columna 'fecha_hora'
data['fecha_hora'] = pd.to_datetime(data['fecha'].astype(str) + ' ' + data['hora'].apply(lambda x: x.zfill(2) + ':00:00'))

data.drop(['Fecha','Hora','fecha','hora'], axis=1, inplace=True)
data.rename(columns={'fecha_hora': 'Fecha'}, inplace=True)
data.rename(columns={'Valor': 'Real'}, inplace=True)

#data_filtrado = data[data['Real'] > 0]  # Ajusta este umbral según sea necesario
#data = data_filtrado

real = data

real

real.describe(include='all').round(1)

# Configuración de visualización
sn.set(style="whitegrid")

# Análisis Descriptivo
descripcion = data['Real'].describe()

# Preparación para análisis temporal y por hora del día
data['Fecha'] = pd.to_datetime(data['Fecha'])  # Asegurar que 'Fecha' es datetime
data['Hora'] = data['Fecha'].dt.hour  # Extraer hora del día

# Análisis Temporal: Visualización de los valores pronosticados a lo largo del tiempo
plt.figure(figsize=(14, 7))
plt.plot(data['Fecha'], data['Real'], label='Valor Real', color='darkorange')
plt.title('Generación Solar Real a lo Largo del Tiempo')
plt.xlabel('Fecha')
plt.ylabel('Valor Real')
plt.xticks(rotation=45)
plt.tight_layout()
plt.legend()
plt.show()

# Análisis por Hora del Día
plt.figure(figsize=(10, 6))
sn.boxplot(x='Hora', y='Real', data=data, palette="coolwarm")
plt.title('Distribución de Valores Pronosticados por Hora del Día')
plt.xlabel('Hora del Día')
plt.ylabel('Valor Real')
plt.tight_layout()

descripcion

# Visualización KDE
sn.kdeplot(real)
plt.show()

"""###Data set Pronostico externo"""

#rutas pronostico externo
ruta1= '/content/drive/MyDrive/CEN/2023/Solar/GenSolarEne23/P.ExternoSolar - ENE23.xlsx'
ruta2= '/content/drive/MyDrive/CEN/2023/Solar/GenSolarFeb23/P.ExternoSolar - FEB23.xlsx'
ruta3= '/content/drive/MyDrive/CEN/2023/Solar/GenSolarMar23/P.ExternoSolar - MAR23.xlsx'
ruta4= '/content/drive/MyDrive/CEN/2023/Solar/GenSolarAbr23/P.ExternoSolar - ABR23.xlsx'
ruta5= '/content/drive/MyDrive/CEN/2023/Solar/GenSolarMay23/P.ExternoSolar - MAY23.xlsx'
ruta6= '/content/drive/MyDrive/CEN/2023/Solar/GenSolarJun23/P.ExternoSolar - JUN23.xlsx'
ruta7= '/content/drive/MyDrive/CEN/2023/Solar/GenSolarJul23/P.ExternoSolar - JUL23.xlsx'
ruta8= '/content/drive/MyDrive/CEN/2023/Solar/GenSolarAgo23/P.ExternoSolar - AGO23.xlsx'
ruta9= '/content/drive/MyDrive/CEN/2023/Solar/GenSolarSep23/P.ExternoSolar - SEP23.xlsx'
ruta10= '/content/drive/MyDrive/CEN/2023/Solar/GenSolarOct23/P.externo - OCT23.xlsx'
ruta11= '/content/drive/MyDrive/CEN/2023/Solar/GenSolarNov23/P. externo Solar - NOV23.xlsx'
ruta12= '/content/drive/MyDrive/CEN/2023/Solar/GenSolarDic23/P. externo Solar - DIC23.xlsx'

df1 = pd.read_excel(ruta1, engine='openpyxl')
df2 = pd.read_excel(ruta2, engine='openpyxl')
df3 = pd.read_excel(ruta3, engine='openpyxl')
df4 = pd.read_excel(ruta4, engine='openpyxl')
df5 = pd.read_excel(ruta5, engine='openpyxl')
df6 = pd.read_excel(ruta6, engine='openpyxl')
df7 = pd.read_excel(ruta7, engine='openpyxl')
df8 = pd.read_excel(ruta8, engine='openpyxl')
df9 = pd.read_excel(ruta9, engine='openpyxl')
df10 = pd.read_excel(ruta10, engine='openpyxl')
df11 = pd.read_excel(ruta11, engine='openpyxl')
df12 = pd.read_excel(ruta12, engine='openpyxl')

merged_df = pd.concat([df1, df2, df3, df4, df5, df6, df7, df8, df9, df10, df11, df12], ignore_index=True)
df_exter = merged_df
data = merged_df

data.rename(columns={'Valor':'Externo'}, inplace=True)
#data_filtrado = data[data['Externo'] > 0]  # Ajusta este umbral según sea necesario
#data = data_filtrado

externo = data
externo

# Configuración de visualización
#data = df7
sn.set(style="whitegrid")

# Análisis Descriptivo
descripcion = data['Externo'].describe()

# Preparación para análisis temporal y por hora del día
data['Fecha'] = pd.to_datetime(data['Fecha'])  # Asegurar que 'Fecha' es datetime
data['Hora'] = data['Fecha'].dt.hour  # Extraer hora del día

# Análisis Temporal: Visualización de los valores pronosticados a lo largo del tiempo
plt.figure(figsize=(14, 7))
plt.plot(data['Fecha'], data['Externo'], label=' Valor Pronosticado Externo', color='darkorange')
plt.title('Pronóstico de Generación Solar Externo a lo Largo del Tiempo')
plt.xlabel('Fecha')
plt.ylabel('Pronosticado Externo')
plt.xticks(rotation=45)
plt.tight_layout()
plt.legend()
plt.show()

# Análisis por Hora del Día
plt.figure(figsize=(10, 6))
sn.boxplot(x='Hora', y='Externo', data=data, palette="coolwarm")
plt.title('Distribución de Valores Pronosticados por Hora del Día')
plt.xlabel('Hora del Día')
plt.ylabel('Valor Pronostico Externo')
plt.tight_layout()

descripcion

"""###Data set Coordinados"""

#rutas pronosticos coordinados
ruta1= '/content/drive/MyDrive/CEN/2023/Solar/GenSolarEne23/CoordinadosSolar - ENE23.xlsx'
ruta2= '/content/drive/MyDrive/CEN/2023/Solar/GenSolarFeb23/CoordinadosSolar - FEB23.xlsx'
ruta3= '/content/drive/MyDrive/CEN/2023/Solar/GenSolarMar23/CoordinadosSolar - MAR23.xlsx'
ruta4= '/content/drive/MyDrive/CEN/2023/Solar/GenSolarAbr23/CoordinadosSolar - ABR23.xlsx'
ruta5= '/content/drive/MyDrive/CEN/2023/Solar/GenSolarMay23/CoordinadosSolar - MAY23.xlsx'
ruta6= '/content/drive/MyDrive/CEN/2023/Solar/GenSolarJun23/CoordinadosSolar - JUN23.xlsx'
ruta7= '/content/drive/MyDrive/CEN/2023/Solar/GenSolarJul23/CoordinadosSolar - JUL23.xlsx'
ruta8= '/content/drive/MyDrive/CEN/2023/Solar/GenSolarAgo23/CoordinadosSolar - AGO23.xlsx'
ruta9= '/content/drive/MyDrive/CEN/2023/Solar/GenSolarSep23/CoordinadosSolar - SEP23.xlsx'
ruta10= '/content/drive/MyDrive/CEN/2023/Solar/GenSolarOct23/CoordinadosSolar - OCT23.xlsx'
ruta11= '/content/drive/MyDrive/CEN/2023/Solar/GenSolarNov23/CoordinadosSolar - NOV23.xlsx'
ruta12= '/content/drive/MyDrive/CEN/2023/Solar/GenSolarDic23/CoordinadosSolar - DIC23.xlsx'

df1 = pd.read_excel(ruta1, engine='openpyxl')
df2 = pd.read_excel(ruta2, engine='openpyxl')
df3 = pd.read_excel(ruta3, engine='openpyxl')
df4 = pd.read_excel(ruta4, engine='openpyxl')
df5 = pd.read_excel(ruta5, engine='openpyxl')
df6 = pd.read_excel(ruta6, engine='openpyxl')
df7 = pd.read_excel(ruta7, engine='openpyxl')
df8 = pd.read_excel(ruta8, engine='openpyxl')
df9 = pd.read_excel(ruta9, engine='openpyxl')
df10 = pd.read_excel(ruta10, engine='openpyxl')
df11 = pd.read_excel(ruta11, engine='openpyxl')
df12 = pd.read_excel(ruta12, engine='openpyxl')

merged_df = pd.concat([df1, df2, df3, df4, df5, df6, df7, df8, df9, df10, df11, df12], ignore_index=True)
data = merged_df

# Asegurarte de que todos los valores en la columna 'Valor' sean strings antes de aplicar operaciones de strings
data['Valor'] = data['Valor'].astype(str)

# Reemplazar comas por puntos en la columna 'Valor'
data['Valor'] = data['Valor'].str.replace(',', '.')

# Convertir la columna 'Valor' a flotante, manejando los errores con 'coerce'
data['Valor'] = pd.to_numeric(data['Valor'], errors='coerce')

# Mostrar el resultado
print(data)

data.rename(columns={'Valor': 'Coordinado'}, inplace=True)
#data_filtrado = data[data['Coordinado'] > 0]  # Ajusta este umbral según sea necesario
#data = data_filtrado
coordinado = data
coordinado

data.describe(include='all').round(1)

# Configuración de visualización
sn.set(style="whitegrid")

# Análisis Descriptivo
descripcion = data['Coordinado'].describe()

# Preparación para análisis temporal y por hora del día
data['Fecha'] = pd.to_datetime(data['Fecha'])  # Asegurar que 'Fecha' es datetime
data['Hora'] = data['Fecha'].dt.hour  # Extraer hora del día

# Análisis Temporal: Visualización de los valores pronosticados a lo largo del tiempo
plt.figure(figsize=(14, 7))
plt.plot(data['Fecha'], data['Coordinado'], label='Valor Pronosticado Coordinado', color='darkorange')
plt.title('Pronóstico de Generación Solar Coordinado a lo Largo del Tiempo')
plt.xlabel('Fecha')
plt.ylabel('Valor Pronosticado Coordinado')
plt.xticks(rotation=45)
plt.tight_layout()
plt.legend()
plt.show()

# Análisis por Hora del Día
plt.figure(figsize=(10, 6))
sn.boxplot(x='Hora', y='Coordinado', data=data, palette="coolwarm")
plt.title('Distribución de Valores Pronosticados Coordinado por Hora del Día')
plt.xlabel('Hora del Día')
plt.ylabel('Valor Pronosticado Coordinado')
plt.tight_layout()

descripcion

data.describe(include='all').round(1)

data[data['Hora']== 23]

"""### Data set Pronostico Sistema Experto

"""

#rutas pronostico externo
ruta1= '/content/drive/MyDrive/CEN/2023/Solar/GenSolarEne23/SistemaExpertoSolar - ENE23.xlsx'
ruta2= '/content/drive/MyDrive/CEN/2023/Solar/GenSolarFeb23/SistemaExpertoSolar - FEB23.xlsx'
ruta3= '/content/drive/MyDrive/CEN/2023/Solar/GenSolarMar23/SistemaExpertoSolar - MAR23.xlsx'
ruta4= '/content/drive/MyDrive/CEN/2023/Solar/GenSolarAbr23/SistemaExpertoSolar - ABR23.xlsx'
ruta5= '/content/drive/MyDrive/CEN/2023/Solar/GenSolarMay23/SistemaExpertoSolar - MAY23.xlsx'
ruta6= '/content/drive/MyDrive/CEN/2023/Solar/GenSolarJun23/SistemaExpertoSolar - JUN23.xlsx'
ruta7= '/content/drive/MyDrive/CEN/2023/Solar/GenSolarJul23/SistemaExpertoSolar - JUL23.xlsx'
ruta8= '/content/drive/MyDrive/CEN/2023/Solar/GenSolarAgo23/SistemaExpertoSolar - AGO23.xlsx'
ruta9= '/content/drive/MyDrive/CEN/2023/Solar/GenSolarSep23/SistemaExpertoSolar - SEP23.xlsx'
ruta10= '/content/drive/MyDrive/CEN/2023/Solar/GenSolarOct23/SistemaExpertoSolar - OCT23.xlsx'
ruta11= '/content/drive/MyDrive/CEN/2023/Solar/GenSolarNov23/SistemaExpertoSolar - NOV23.xlsx'
ruta12= '/content/drive/MyDrive/CEN/2023/Solar/GenSolarDic23/SistemaExpertoSolar - DIC23.xlsx'

df1 = pd.read_excel(ruta1, engine='openpyxl')
df2 = pd.read_excel(ruta2, engine='openpyxl')
df3 = pd.read_excel(ruta3, engine='openpyxl')
df4 = pd.read_excel(ruta4, engine='openpyxl')
df5 = pd.read_excel(ruta5, engine='openpyxl')
df6 = pd.read_excel(ruta6, engine='openpyxl')
df7 = pd.read_excel(ruta7, engine='openpyxl')
df8 = pd.read_excel(ruta8, engine='openpyxl')
df9 = pd.read_excel(ruta9, engine='openpyxl')
df10 = pd.read_excel(ruta10, engine='openpyxl')
df11 = pd.read_excel(ruta11, engine='openpyxl')
df12 = pd.read_excel(ruta12, engine='openpyxl')

merged_df = pd.concat([df1, df2, df3, df4, df5, df6, df7, df8, df9, df10, df11, df12], ignore_index=True)

data = merged_df

data.rename(columns={'Valor':'SExperto'}, inplace=True)
SExperto= data
SExperto

# Configuración de visualización
#data = df7
sn.set(style="whitegrid")

# Análisis Descriptivo
descripcion = data['SExperto'].describe()

# Preparación para análisis temporal y por hora del día
data['Fecha'] = pd.to_datetime(data['Fecha'])  # Asegurar que 'Fecha' es datetime
data['Hora'] = data['Fecha'].dt.hour  # Extraer hora del día

# Análisis Temporal: Visualización de los valores pronosticados a lo largo del tiempo
plt.figure(figsize=(14, 7))
plt.plot(data['Fecha'], data['SExperto'], label='Valor Pronosticado SExperto', color='darkorange')
plt.title('Pronóstico de Generación Solar SExperto a lo Largo del Tiempo')
plt.xlabel('Fecha')
plt.ylabel('Valor Pronosticado SExperto')
plt.xticks(rotation=45)
plt.tight_layout()
plt.legend()
plt.show()

# Análisis por Hora del Día
plt.figure(figsize=(10, 6))
sn.boxplot(x='Hora', y='SExperto', data=data, palette="coolwarm")
plt.title('Distribución de Valores Pronosticados SExperto por Hora del Día')
plt.xlabel('Hora del Día')
plt.ylabel('Valor Pronosticado SExperto')
plt.tight_layout()

descripcion

"""###Data Set Vertimiento"""

ruta1= '/content/drive/MyDrive/CEN/2023/Solar/GenSolarEne23/Vertimiento - ENE23.xlsx'
ruta2= '/content/drive/MyDrive/CEN/2023/Solar/GenSolarFeb23/Vertimiento - FEB23.xlsx'
ruta3= '/content/drive/MyDrive/CEN/2023/Solar/GenSolarMar23/Vertimiento - MAR23.xlsx'
ruta4= '/content/drive/MyDrive/CEN/2023/Solar/GenSolarAbr23/Vertimiento - ABR23.xlsx'
ruta5= '/content/drive/MyDrive/CEN/2023/Solar/GenSolarMay23/Vertimiento - MAY23.xlsx'
ruta6= '/content/drive/MyDrive/CEN/2023/Solar/GenSolarJun23/Vertimiento - JUN23.xlsx'
ruta7= '/content/drive/MyDrive/CEN/2023/Solar/GenSolarJul23/Vertimiento - JUL23.xlsx'
ruta8= '/content/drive/MyDrive/CEN/2023/Solar/GenSolarAgo23/Vertimiento - AGO23.xlsx'
ruta9= '/content/drive/MyDrive/CEN/2023/Solar/GenSolarSep23/Vertimiento - SEP23.xlsx'
ruta10= '/content/drive/MyDrive/CEN/2023/Solar/GenSolarOct23/Vertimiento - OCT23.xlsx'
ruta11= '/content/drive/MyDrive/CEN/2023/Solar/GenSolarNov23/Vertimiento - NOV23.xlsx'
ruta12= '/content/drive/MyDrive/CEN/2023/Solar/GenSolarDic23/Vertimiento - DIC23.xlsx'

df1 = pd.read_excel(ruta1, engine='openpyxl')
df2 = pd.read_excel(ruta2, engine='openpyxl')
df3 = pd.read_excel(ruta3, engine='openpyxl')
df4 = pd.read_excel(ruta4, engine='openpyxl')
df5 = pd.read_excel(ruta5, engine='openpyxl')
df6 = pd.read_excel(ruta6, engine='openpyxl')
df7 = pd.read_excel(ruta7, engine='openpyxl')
df8 = pd.read_excel(ruta8, engine='openpyxl')
df9 = pd.read_excel(ruta9, engine='openpyxl')
df10 = pd.read_excel(ruta10, engine='openpyxl')
df11 = pd.read_excel(ruta11, engine='openpyxl')
df12 = pd.read_excel(ruta12, engine='openpyxl')

merged_df = pd.concat([df1, df2, df3, df4, df5, df6, df7, df8, df9, df10, df11, df12], ignore_index=True)

data = merged_df

data.rename(columns={'Valor':'Vertimiento'}, inplace=True)
Vertimiento= data
Vertimiento

# Configuración de visualización
#data = df7
sn.set(style="whitegrid")

# Análisis Descriptivo
descripcion = data['Vertimiento'].describe()

# Preparación para análisis temporal y por hora del día
data['Fecha'] = pd.to_datetime(data['Fecha'])  # Asegurar que 'Fecha' es datetime
data['Hora'] = data['Fecha'].dt.hour  # Extraer hora del día

# Análisis Temporal: Visualización de los valores pronosticados a lo largo del tiempo
plt.figure(figsize=(14, 7))
plt.plot(data['Fecha'], data['Vertimiento'], label='Valor Vertimiento', color='darkorange')
plt.title('Generación Solar Vertimiento a lo Largo del Tiempo')
plt.xlabel('Fecha')
plt.ylabel('Valor Vertimiento')
plt.xticks(rotation=45)
plt.tight_layout()
plt.legend()
plt.show()

# Análisis por Hora del Día
plt.figure(figsize=(10, 6))
sn.boxplot(x='Hora', y='Vertimiento', data=data, palette="coolwarm")
plt.title('Distribución de Valores  Vertimiento por Hora del Día')
plt.xlabel('Hora del Día')
plt.ylabel('Valor Pronosticado Vertimiento')
plt.tight_layout()

descripcion

"""###Union dataframes"""

real
externo
coordinado
SExperto
Vertimiento

df_cruzado = pd.merge(real, externo,  on=['Nombre', 'Fecha'], how='outer')
df_cruzado.drop(['Hora_x', 'Hora_y'],axis=1, inplace=True)
df_cruzado = pd.merge(df_cruzado, coordinado,  on=['Nombre', 'Fecha'], how='outer')
df_cruzado.drop(['Hora'],axis=1, inplace=True)
df_cruzado = pd.merge(df_cruzado, SExperto,  on=['Nombre', 'Fecha'], how='outer')
df_cruzado.drop(['Hora'],axis=1, inplace=True)
df_cruzado = pd.merge(df_cruzado, Vertimiento,  on=['Nombre', 'Fecha'], how='outer')
df_cruzado.drop(['Hora'],axis=1, inplace=True)

df = df_cruzado
Pronosticos = df_cruzado
#df['generacion_potencial'] = df['Real'] + df['Vertimiento'].fillna(0)
df['Tecnologia'] = 'Solar'
df_solar = df
df_solar

"""##Eólico

###Data Set Real Eólica
"""

#rutas Generación Real
ruta1= '/content/drive/MyDrive/CEN/2023/Eolico/Datos Eólicos Enero 2023/RealEolico - ENE23.xlsx'
ruta2= '/content/drive/MyDrive/CEN/2023/Eolico/Datos Eólicos Febrero 2023/RealEolico - FEB23.xlsx'
ruta3= '/content/drive/MyDrive/CEN/2023/Eolico/Datos Eólicos Marzo 2023/RealEolico - MAR23.xlsx'
ruta4= '/content/drive/MyDrive/CEN/2023/Eolico/Datos Eólicos Abril 2023/RealEolico - ABR23.xlsx'
ruta5= '/content/drive/MyDrive/CEN/2023/Eolico/Eolico-Mayo-2023/Datos Eólicos Mayo 2023/RealEolico - MAY23.xlsx'
ruta6= '/content/drive/MyDrive/CEN/2023/Eolico/Datos Eólicos Junio 2023/RealEolico - JUN23.xlsx'
ruta7= '/content/drive/MyDrive/CEN/2023/Eolico/Datos Eólicos Julio 2023/RealEolico - JUL23.xlsx'
ruta8= '/content/drive/MyDrive/CEN/2023/Eolico/Datos Eólicos Agosto 2023/RealEolico - AGO23.xlsx'
ruta9= '/content/drive/MyDrive/CEN/2023/Eolico/Eolico-Septiembre-2023/Datos eólicos septiembre 2023/RealEolico - SEP23.xlsx'
ruta10= '/content/drive/MyDrive/CEN/2023/Eolico/Eolico-Octubre-2023/Datos eólicos octubre 2023/RealEolico - OCT23.xlsx'
ruta11= '/content/drive/MyDrive/CEN/2023/Eolico/Eolico-Noviembre-2023/Datos eólicos noviembre 2023/RealEolico - NOV23.xlsx'
ruta12= '/content/drive/MyDrive/CEN/2023/Eolico/Eolico-Diciembre-2023/Datos eólicos diciembre 2023/RealEolico - DIC23.xlsx'

#Definición de dataframes
df1 = pd.read_excel(ruta1, engine='openpyxl')
df2 = pd.read_excel(ruta2, engine='openpyxl')
df3 = pd.read_excel(ruta3, engine='openpyxl')
df4 = pd.read_excel(ruta4, engine='openpyxl')
df5 = pd.read_excel(ruta5, engine='openpyxl')
df6 = pd.read_excel(ruta6, engine='openpyxl')
df7 = pd.read_excel(ruta7, engine='openpyxl')
df8 = pd.read_excel(ruta8, engine='openpyxl')
df9 = pd.read_excel(ruta9, engine='openpyxl')
df10 = pd.read_excel(ruta10, engine='openpyxl')
df11 = pd.read_excel(ruta11, engine='openpyxl')
df12 = pd.read_excel(ruta12, engine='openpyxl')

merged_df = pd.concat([df1, df2, df3, df4, df5, df6, df7, df8, df9, df10, df11, df12], ignore_index=True)
data = merged_df
real = data

# Primero, convertimos la columna 'fecha' a datetime y 'hora' a string para manejar el caso de '24'
data['fecha'] = pd.to_datetime(data['Fecha'])
data['hora'] = data['Hora'].astype(str)

# Manejar el caso especial de la hora '24'
data.loc[data['hora'] == '24', 'fecha'] += pd.Timedelta(days=1)
data.loc[data['hora'] == '24', 'hora'] = '00'

# Ahora, combinar las columnas 'fecha' y 'hora' en una nueva columna 'fecha_hora'
data['fecha_hora'] = pd.to_datetime(data['fecha'].astype(str) + ' ' + data['hora'].apply(lambda x: x.zfill(2) + ':00:00'))

data.drop(['Fecha','Hora','fecha','hora'], axis=1, inplace=True)
data.rename(columns={'fecha_hora': 'Fecha'}, inplace=True)
data.rename(columns={'Valor': 'Real'}, inplace=True)

real = data
real

real = data
real.describe(include='all').round(1)

# Configuración de visualización
sn.set(style="whitegrid")

# Análisis Descriptivo
descripcion = data['Real'].describe()

# Preparación para análisis temporal y por hora del día
data['Fecha'] = pd.to_datetime(data['Fecha'])  # Asegurar que 'Fecha' es datetime
data['Hora'] = data['Fecha'].dt.hour  # Extraer hora del día

# Análisis Temporal: Visualización de los valores pronosticados a lo largo del tiempo
plt.figure(figsize=(14, 7))
plt.plot(data['Fecha'], data['Real'], label='Valor Pronosticado Real', color='darkorange')
plt.title('Pronóstico de Generación Solar a lo Largo del Tiempo')
plt.xlabel('Fecha')
plt.ylabel('Valor Pronosticado Real')
plt.xticks(rotation=45)
plt.tight_layout()
plt.legend()
plt.show()

# Análisis por Hora del Día
plt.figure(figsize=(10, 6))
sn.boxplot(x='Hora', y='Real', data=data, palette="coolwarm")
plt.title('Distribución de Valores Pronostico Real por Hora del Día')
plt.xlabel('Hora del Día')
plt.ylabel('Valor Pronosticado Real')
plt.tight_layout()

descripcion

"""###Data set Pronostico externo"""

#rutas pronostico externo
ruta1= '/content/drive/MyDrive/CEN/2023/Eolico/Datos Eólicos Enero 2023/P.ExternoEolico- ENE23.xlsx'
ruta2= '/content/drive/MyDrive/CEN/2023/Eolico/Datos Eólicos Febrero 2023/P.ExternoEolico - FEB23.xlsx'
ruta3= '/content/drive/MyDrive/CEN/2023/Eolico/Datos Eólicos Marzo 2023/P.ExternoEolico - MAR23.xlsx'
ruta4= '/content/drive/MyDrive/CEN/2023/Eolico/Datos Eólicos Abril 2023/P.ExternoEolico - ABR23.xlsx'
ruta5= '/content/drive/MyDrive/CEN/2023/Eolico/Eolico-Mayo-2023/Datos Eólicos Mayo 2023/P.ExternoEolico - MAY23.xlsx'
ruta6= '/content/drive/MyDrive/CEN/2023/Eolico/Datos Eólicos Junio 2023/P.ExternoEolico - JUN23.xlsx'
ruta7= '/content/drive/MyDrive/CEN/2023/Eolico/Datos Eólicos Julio 2023/P.ExternoEolico- JUL23.xlsx'
ruta8= '/content/drive/MyDrive/CEN/2023/Eolico/Datos Eólicos Agosto 2023/P.ExternoEolico - AGO23.xlsx'
ruta9= '/content/drive/MyDrive/CEN/2023/Eolico/Eolico-Septiembre-2023/Datos eólicos septiembre 2023/P.ExternoEolico - SEP23.xlsx'
ruta10= '/content/drive/MyDrive/CEN/2023/Eolico/Eolico-Octubre-2023/Datos eólicos octubre 2023/PExternoEolico - OCT23.xlsx'
ruta11= '/content/drive/MyDrive/CEN/2023/Eolico/Eolico-Noviembre-2023/Datos eólicos noviembre 2023/P.ExternoEolico - NOV23.xlsx'
ruta12= '/content/drive/MyDrive/CEN/2023/Eolico/Eolico-Diciembre-2023/Datos eólicos diciembre 2023/P.ExternoEolico - DIC23.xlsx'

df1 = pd.read_excel(ruta1, engine='openpyxl')
df2 = pd.read_excel(ruta2, engine='openpyxl')
df3 = pd.read_excel(ruta3, engine='openpyxl')
df4 = pd.read_excel(ruta4, engine='openpyxl')
df5 = pd.read_excel(ruta5, engine='openpyxl')
df6 = pd.read_excel(ruta6, engine='openpyxl')
df7 = pd.read_excel(ruta7, engine='openpyxl')
df8 = pd.read_excel(ruta8, engine='openpyxl')
df9 = pd.read_excel(ruta9, engine='openpyxl')
df10 = pd.read_excel(ruta10, engine='openpyxl')
df11 = pd.read_excel(ruta11, engine='openpyxl')
df12 = pd.read_excel(ruta12, engine='openpyxl')

merged_df = pd.concat([df1, df2, df3, df4, df5, df6, df7, df8, df9, df10, df11, df12], ignore_index=True)
externo = merged_df
externo.rename(columns={'Valor':'Externo'}, inplace=True)
data = merged_df

externo

# Configuración de visualización
#data = df7
sn.set(style="whitegrid")

# Análisis Descriptivo
descripcion = data['Externo'].describe()

# Preparación para análisis temporal y por hora del día
data['Fecha'] = pd.to_datetime(data['Fecha'])  # Asegurar que 'Fecha' es datetime
data['Hora'] = data['Fecha'].dt.hour  # Extraer hora del día

# Análisis Temporal: Visualización de los valores pronosticados a lo largo del tiempo
plt.figure(figsize=(14, 7))
plt.plot(data['Fecha'], data['Externo'], label='Valor Pronostico Externo', color='darkorange')
plt.title('Pronóstico Externo de Generación Solar a lo Largo del Tiempo')
plt.xlabel('Fecha')
plt.ylabel('Valor Pronostico Externo')
plt.xticks(rotation=45)
plt.tight_layout()
plt.legend()
plt.show()

# Análisis por Hora del Día
plt.figure(figsize=(10, 6))
sn.boxplot(x='Hora', y='Externo', data=data, palette="coolwarm")
plt.title('Distribución de Valores Pronosticados por Hora del Día')
plt.xlabel('Hora del Día')
plt.ylabel('Valor Pronostico Externo')
plt.tight_layout()

descripcion

"""###Data set Coordinados"""

#rutas pronosticos coordinados
ruta1= '/content/drive/MyDrive/CEN/2023/Eolico/Datos Eólicos Enero 2023/CoordinadosEolico - ENE23.xlsx'
ruta2= '/content/drive/MyDrive/CEN/2023/Eolico/Datos Eólicos Febrero 2023/CoordinadosEolico - FEB23.xlsx'
ruta3= '/content/drive/MyDrive/CEN/2023/Eolico/Datos Eólicos Marzo 2023/CoordinadosEolico - MAR23.xlsx'
ruta4= '/content/drive/MyDrive/CEN/2023/Eolico/Datos Eólicos Abril 2023/CoordinadosEolico - ABR23.xlsx'
ruta5= '/content/drive/MyDrive/CEN/2023/Eolico/Eolico-Mayo-2023/Datos Eólicos Mayo 2023/CoordinadosEolico - MAY23.xlsx'
ruta6= '/content/drive/MyDrive/CEN/2023/Eolico/Datos Eólicos Junio 2023/CoordinadosEolico - JUN23.xlsx'
ruta7= '/content/drive/MyDrive/CEN/2023/Eolico/Datos Eólicos Julio 2023/CoordinadosEolico - JUL23.xlsx'
ruta8= '/content/drive/MyDrive/CEN/2023/Eolico/Datos Eólicos Agosto 2023/CoordinadosEolico - AGO23.xlsx'
ruta9= '/content/drive/MyDrive/CEN/2023/Eolico/Eolico-Septiembre-2023/Datos eólicos septiembre 2023/CoordinadosEolico - SEP23.xlsx'
ruta10= '/content/drive/MyDrive/CEN/2023/Eolico/Eolico-Octubre-2023/Datos eólicos octubre 2023/CoordinadosEolico - OCT23.xlsx'
ruta11= '/content/drive/MyDrive/CEN/2023/Eolico/Eolico-Noviembre-2023/Datos eólicos noviembre 2023/CoordinadosEolico - NOV23.xlsx'
ruta12= '/content/drive/MyDrive/CEN/2023/Eolico/Eolico-Diciembre-2023/Datos eólicos diciembre 2023/CoordinadosEolico - DIC23.xlsx'

df1 = pd.read_excel(ruta1, engine='openpyxl')
df2 = pd.read_excel(ruta2, engine='openpyxl')
df3 = pd.read_excel(ruta3, engine='openpyxl')
df4 = pd.read_excel(ruta4, engine='openpyxl')
df5 = pd.read_excel(ruta5, engine='openpyxl')
df6 = pd.read_excel(ruta6, engine='openpyxl')
df7 = pd.read_excel(ruta7, engine='openpyxl')
df8 = pd.read_excel(ruta8, engine='openpyxl')
df9 = pd.read_excel(ruta9, engine='openpyxl')
df10 = pd.read_excel(ruta10, engine='openpyxl')
df11 = pd.read_excel(ruta11, engine='openpyxl')
df12 = pd.read_excel(ruta12, engine='openpyxl')

merged_df = pd.concat([df1, df2, df3, df4, df5, df6, df7, df8, df9, df10, df11, df12], ignore_index=True)
data = merged_df
coordinado = data
coordinado.rename(columns={'Valor':'Coordinado'}, inplace=True)

data.dtypes

coordinado

data.describe(include='all').round(1)

# Configuración de visualización
sn.set(style="whitegrid")

# Análisis Descriptivo
descripcion = data['Coordinado'].describe()

# Preparación para análisis temporal y por hora del día
data['Fecha'] = pd.to_datetime(data['Fecha'])  # Asegurar que 'Fecha' es datetime
data['Hora'] = data['Fecha'].dt.hour  # Extraer hora del día

# Análisis Temporal: Visualización de los valores pronosticados a lo largo del tiempo
plt.figure(figsize=(14, 7))
plt.plot(data['Fecha'], data['Coordinado'], label='Valor Pronosticado Coordinado', color='darkorange')
plt.title('Pronóstico de Generación Solar a lo Largo del Tiempo')
plt.xlabel('Fecha')
plt.ylabel('Valor Pronostico Coordinado')
plt.xticks(rotation=45)
plt.tight_layout()
plt.legend()
plt.show()

# Análisis por Hora del Día
plt.figure(figsize=(10, 6))
sn.boxplot(x='Hora', y='Coordinado', data=data, palette="coolwarm")
plt.title('Distribución de Valores Pronosticados Coordinado por Hora del Día')
plt.xlabel('Hora del Día')
plt.ylabel('Valor Pronosticado Coordinado')
plt.tight_layout()

descripcion

"""###Data set Pronostico Sistema Experto

"""

#rutas pronostico externo
ruta1= '/content/drive/MyDrive/CEN/2023/Eolico/Datos Eólicos Enero 2023/SistemaExpertoEolico - ENE23.xlsx'
ruta2= '/content/drive/MyDrive/CEN/2023/Eolico/Datos Eólicos Febrero 2023/SistemaExpertoEolico - FEB23.xlsx'
ruta3= '/content/drive/MyDrive/CEN/2023/Eolico/Datos Eólicos Marzo 2023/SistemaExpertoEolico - MAR23.xlsx'
ruta4= '/content/drive/MyDrive/CEN/2023/Eolico/Datos Eólicos Abril 2023/SistemaExpertoEolico - ABR23.xlsx'
ruta5= '/content/drive/MyDrive/CEN/2023/Eolico/Eolico-Mayo-2023/Datos Eólicos Mayo 2023/SistemaExpertoEolico - MAY23.xlsx'
ruta6= '/content/drive/MyDrive/CEN/2023/Eolico/Datos Eólicos Junio 2023/SistemaExpertoEolico - JUN23.xlsx'
ruta7= '/content/drive/MyDrive/CEN/2023/Eolico/Datos Eólicos Julio 2023/SistemaExpertoEolico - JUL23.xlsx'
ruta8= '/content/drive/MyDrive/CEN/2023/Eolico/Datos Eólicos Agosto 2023/SistemaExpertoEolico - AGO23.xlsx'
ruta9= '/content/drive/MyDrive/CEN/2023/Eolico/Eolico-Septiembre-2023/Datos eólicos septiembre 2023/SistemaExpertoEolico - SEP23.xlsx'
ruta10= '/content/drive/MyDrive/CEN/2023/Eolico/Eolico-Octubre-2023/Datos eólicos octubre 2023/SistemaExpertoEolico - OCT23.xlsx'
ruta11= '/content/drive/MyDrive/CEN/2023/Eolico/Eolico-Noviembre-2023/Datos eólicos noviembre 2023/SistemaExpertoEolico - NOV23.xlsx'
ruta12= '/content/drive/MyDrive/CEN/2023/Eolico/Eolico-Diciembre-2023/Datos eólicos diciembre 2023/SistemaExpertoEolico - DIC23.xlsx'

df1 = pd.read_excel(ruta1, engine='openpyxl')
df2 = pd.read_excel(ruta2, engine='openpyxl')
df3 = pd.read_excel(ruta3, engine='openpyxl')
df4 = pd.read_excel(ruta4, engine='openpyxl')
df5 = pd.read_excel(ruta5, engine='openpyxl')
df6 = pd.read_excel(ruta6, engine='openpyxl')
df7 = pd.read_excel(ruta7, engine='openpyxl')
df8 = pd.read_excel(ruta8, engine='openpyxl')
df9 = pd.read_excel(ruta9, engine='openpyxl')
df10 = pd.read_excel(ruta10, engine='openpyxl')
df11 = pd.read_excel(ruta11, engine='openpyxl')
df12 = pd.read_excel(ruta12, engine='openpyxl')

merged_df = pd.concat([df1, df2, df3, df4, df5, df6, df7, df8, df9, df10, df11, df12], ignore_index=True)
SExperto = merged_df
SExperto.rename(columns={'Valor':'SExperto'}, inplace=True)
data = merged_df

SExperto

# Configuración de visualización
#data = df7
sn.set(style="whitegrid")

# Análisis Descriptivo
descripcion = data['SExperto'].describe()

# Preparación para análisis temporal y por hora del día
data['Fecha'] = pd.to_datetime(data['Fecha'])  # Asegurar que 'Fecha' es datetime
data['Hora'] = data['Fecha'].dt.hour  # Extraer hora del día

# Análisis Temporal: Visualización de los valores pronosticados a lo largo del tiempo
plt.figure(figsize=(14, 7))
plt.plot(data['Fecha'], data['SExperto'], label='Valor Pronosticado SExperto', color='darkorange')
plt.title('Pronóstico SExperto de Generación Solar a lo Largo del Tiempo')
plt.xlabel('Fecha')
plt.ylabel('Valor Pronosticado SExperto')
plt.xticks(rotation=45)
plt.tight_layout()
plt.legend()
plt.show()

# Análisis por Hora del Día
plt.figure(figsize=(10, 6))
sn.boxplot(x='Hora', y='SExperto', data=data, palette="coolwarm")
plt.title('Distribución de Valores Pronosticados SExperto por Hora del Día')
plt.xlabel('Hora del Día')
plt.ylabel('Valor Pronosticado SExperto')
plt.tight_layout()

descripcion

"""###Data Set Vertimiento"""

ruta1= '/content/drive/MyDrive/CEN/2023/Eolico/Datos Eólicos Enero 2023/Vertimiento - ENE23.xlsx'
ruta2= '/content/drive/MyDrive/CEN/2023/Eolico/Datos Eólicos Febrero 2023/Vertimiento - FEB23.xlsx'
ruta3= '/content/drive/MyDrive/CEN/2023/Eolico/Datos Eólicos Marzo 2023/Vertimiento - MAR23.xlsx'
ruta4= '/content/drive/MyDrive/CEN/2023/Eolico/Datos Eólicos Abril 2023/Vertimiento - ABR23.xlsx'
ruta5= '/content/drive/MyDrive/CEN/2023/Eolico/Eolico-Mayo-2023/Datos Eólicos Mayo 2023/Vertimiento - MAY23.xlsx'
ruta6= '/content/drive/MyDrive/CEN/2023/Eolico/Datos Eólicos Junio 2023/Vertimiento - JUN23.xlsx'
ruta7= '/content/drive/MyDrive/CEN/2023/Eolico/Datos Eólicos Julio 2023/Vertimiento - JUL23.xlsx'
ruta8= '/content/drive/MyDrive/CEN/2023/Eolico/Datos Eólicos Agosto 2023/Vertimiento - AGO23.xlsx'
ruta9= '/content/drive/MyDrive/CEN/2023/Eolico/Eolico-Septiembre-2023/Datos eólicos septiembre 2023/Vertimiento - SEP23.xlsx'
ruta10= '/content/drive/MyDrive/CEN/2023/Eolico/Eolico-Octubre-2023/Datos eólicos octubre 2023/Vertimiento - OCT23.xlsx'
ruta11= '/content/drive/MyDrive/CEN/2023/Eolico/Eolico-Noviembre-2023/Datos eólicos noviembre 2023/Vertimiento - NOV23.xlsx'
ruta12= '/content/drive/MyDrive/CEN/2023/Eolico/Eolico-Diciembre-2023/Datos eólicos diciembre 2023/Vertimiento - DIC23.xlsx'

df1 = pd.read_excel(ruta1, engine='openpyxl')
df2 = pd.read_excel(ruta2, engine='openpyxl')
df3 = pd.read_excel(ruta3, engine='openpyxl')
df4 = pd.read_excel(ruta4, engine='openpyxl')
df5 = pd.read_excel(ruta5, engine='openpyxl')
df6 = pd.read_excel(ruta6, engine='openpyxl')
df7 = pd.read_excel(ruta7, engine='openpyxl')
df8 = pd.read_excel(ruta8, engine='openpyxl')
df9 = pd.read_excel(ruta9, engine='openpyxl')
df10 = pd.read_excel(ruta10, engine='openpyxl')
df11 = pd.read_excel(ruta11, engine='openpyxl')
df12 = pd.read_excel(ruta12, engine='openpyxl')

merged_df = pd.concat([df1, df2, df3, df4, df5, df6, df7, df8, df9, df10, df11, df12], ignore_index=True)

data = merged_df

data.describe(include='all').round(1)

data = data[data['Valor'] != '-']

data['Valor'] = data['Valor'].astype(float)
data.dtypes

data.rename(columns={'Valor':'Vertimiento'}, inplace=True)
Vertimiento= data
Vertimiento.describe(include='all').round(1)

# Configuración de visualización
#data = df7
sn.set(style="whitegrid")

# Análisis Descriptivo
descripcion = data['Vertimiento'].describe()

# Preparación para análisis temporal y por hora del día
data['Fecha'] = pd.to_datetime(data['Fecha'])  # Asegurar que 'Fecha' es datetime
data['Hora'] = data['Fecha'].dt.hour  # Extraer hora del día

# Análisis Temporal: Visualización de los valores pronosticados a lo largo del tiempo
plt.figure(figsize=(14, 7))
plt.plot(data['Fecha'], data['Vertimiento'], label='Valor Vertimiento', color='darkorange')
plt.title('Generación Eolica Vertimiento a lo Largo del Tiempo')
plt.xlabel('Fecha')
plt.ylabel('Valor Vertimiento')
plt.xticks(rotation=45)
plt.tight_layout()
plt.legend()
plt.show()

# Análisis por Hora del Día
plt.figure(figsize=(10, 6))
sn.boxplot(x='Hora', y='Vertimiento', data=data, palette="coolwarm")
plt.title('Distribución de Valores  Vertimiento por Hora del Día')
plt.xlabel('Hora del Día')
plt.ylabel('Valor Pronosticado Vertimiento')
plt.tight_layout()

descripcion

"""###Union dataframes"""

real
externo
coordinado
SExperto
Vertimiento

df_cruzado = pd.merge(real, externo,  on=['Nombre', 'Fecha'], how='outer')
df_cruzado.drop(['Hora_x', 'Hora_y'],axis=1, inplace=True)
df_cruzado = pd.merge(df_cruzado, coordinado,  on=['Nombre', 'Fecha'], how='outer')
df_cruzado.drop(['Hora'],axis=1, inplace=True)
df_cruzado = pd.merge(df_cruzado, SExperto,  on=['Nombre', 'Fecha'], how='outer')
df_cruzado.drop(['Hora'],axis=1, inplace=True)
df_cruzado = pd.merge(df_cruzado, Vertimiento,  on=['Nombre', 'Fecha'], how='outer')
df_cruzado.drop(['Hora'],axis=1, inplace=True)

df = df_cruzado
Pronosticos = df_cruzado
#df['generacion_potencial'] = df['Real'] + df['Vertimiento'].fillna(0)
df['Tecnologia'] = 'Eolico'
df_eolico = df
df_eolico

"""##Centrales"""

df_unido = pd.merge(df_solar,df_eolico,  how='outer')
df_unido

df_unido['Nombre'].unique()
#len(df_unido['Nombre'].unique())

rutaC= '/content/drive/MyDrive/CEN/reporte_centrales.xlsx'
dfc = pd.read_excel(rutaC, engine='openpyxl')

dfc['Tipo Central'].unique()
dfc.columns

#dfcS = dfc[dfc['Tipo Central'] == 'Solares']
dfcS = dfc[dfc['Nombre'].isin(df_unido['Nombre'].unique())]
dfcS.describe(include='all').round(1)
dfcS.columns
dfcc = dfcS[ ['Nombre','11.1.38 Región','11.1.8 Provincia', '11.1.8 Comuna', '11.1.4 Potencia máxima bruta, para cada tipo de combustible que pueda operar','Nombre Propietario']].copy()
dfcc.rename(columns={'11.1.4 Potencia máxima bruta, para cada tipo de combustible que pueda operar': 'Potencia_max_bruta','11.1.38 Región': 'Region','11.1.8 Provincia': 'Provincia', '11.1.8 Comuna': 'Comuna'}, inplace=True)
dfcc['Potencia_max_bruta'] = pd.to_numeric(dfcc['Potencia_max_bruta'], errors='coerce')
dfcc['Provincia'] = dfcc['Provincia'].str.upper()
dfcc['Provincia'] = dfcc['Provincia'].replace('DEL TAMARUGAL','TAMARUGAL')
dfcc.describe(include='all').round(1)
#dfcc['Region'].unique()
dfcc

# Supongamos que 'dfcc' es tu DataFrame y 'Potencia_max_bruta' es la columna de interés.
# Calculamos el número de bins usando la regla de Sturges.
N = 65  # Número total de filas en el DataFrame
bins = round(1 + np.log2(N))

# Establecer el tamaño de la figura aquí
plt.figure(figsize=(10, 6))

# Ahora generamos el histograma sin el argumento figsize.
n, bins, patches = plt.hist(dfcc['Potencia_max_bruta'], bins=bins, edgecolor='black', alpha=0.7)

# Configuramos las etiquetas y el título del gráfico.
plt.xlabel('Potencia Máxima Bruta')
plt.ylabel('Frecuencia')
plt.title('Distribución de Potencia Máxima Bruta')

# Añadir las frecuencias exactas sobre cada barra.
for i in range(len(n)):
    plt.text(bins[i]+((bins[i+1]-bins[i])/2), n[i], str(int(n[i])), ha='center', va='bottom')

# Mostramos el gráfico.
plt.show()

df_f = pd.merge(df_unido, dfcc, on='Nombre')
df_f
df = df_f
df

"""#Analisis Exlploratorio de datos

El AED consiste en examinar los datos para entenderlos, ver relaciones entre variables y encontrar posibles inconsistencias. Para esto, se analiza estadística descriptiva y gráﬁcos.

##Estadistica descriptiva

Para analizar el comportamiento de los datos de las variables numéricas, obtenemos la media, desviación estandar, mínimo, máximo y cuartiles. Mientras que para las variables categóricas obtenemos la cantidad de categorias de la variable (unique), la moda (top) y la frecuencia de de la moda (freq).
"""

df.describe(include='all').round(1)

df.isnull().sum()

print("Porcentaje de valore perdidos")

a= df['Real'].isnull().sum()/df['Real'].count()
print(f"Real: {100*a.round(4)}%")
a= df['Externo'].isnull().sum()/df['Externo'].count()
print(f"Externo: {100*a.round(4)}%")
b= df['Coordinado'].isnull().sum()/df['Coordinado'].count()
print(f"Coordinado: {100*b.round(4)}%")
c=df['SExperto'].isnull().sum()/df['SExperto'].count()
print(f"S.Experto: {100*c.round(4)}%")
c=df['Vertimiento'].isnull().sum()/df['Vertimiento'].count()
print(f"Vertimiento: {100*c.round(4)}%")

"""##Graficos

Los gráficos nos permiten identificar patrones univariados y bivariados, visualizar los datos y valores atípicos. Veamos primero el Gráfico de frecuencias estándar para la variable Externo:
"""

df.set_index(['Fecha', 'Nombre'], inplace=True)

data.describe(include='all').round(1)
df

columnas = [col for col in df.select_dtypes(include=[np.number]).columns if col != 'Hora']
 # Seleccionamos solo columnas numéricas

# Número de filas y columnas para la cuadrícula de subplots
n_rows = (len(columnas) + 2) // 3  # Asegurar que haya suficientes filas
n_cols = 3  # Máximo de 3 columnas por fila

# Crear una figura grande para acomodar todos los subplots
plt.figure(figsize=(n_cols * 5, n_rows * 4))  # El tamaño puede ser ajustado

# Crear un loop para generar los gráficos para cada columna numérica
for index, column in enumerate(columnas, 1):  # Iniciar el índice en 1 para el subplot
    ax = plt.subplot(n_rows, n_cols, index)
    # Calcular el número de bins para cubrir el rango de la columna con bins de 25 unidades
    min_val = df[column].min()
    max_val = df[column].max()
    bins = np.arange((min_val // 25) * 25, (max_val // 25) * 25 + 50, 25)  # Asegura cobertura hasta el máximo
    # Usar histplot de seaborn para dibujar, distinguiendo por 'TipoEnergia'
    sn.histplot(data=df, x=column, bins=bins, hue='Tecnologia', edgecolor='black', alpha=0.6, ax=ax, palette='viridis')
    plt.title(f'Distribución de {column} por Tipo de Energía')
    plt.xlabel(column)
    plt.ylabel('Frecuencia')

# Ajustar el layout para evitar que los títulos se solapen
plt.tight_layout()

# Mostrar los gráficos
plt.show()

"""Dado que posteriormente queremos calcular el error. Los valores 0, que son gran parte de los datos sesgarían nuestros calculos, por lo que procederemos a filtrarlos"""

# Lista de todas las columnas para iterar
columnas = df.select_dtypes(include=[np.number]).columns

# Número de filas y columnas para la cuadrícula de subplots
n_rows = (len(columnas) + 2) // 3  # Asegurar que haya suficientes filas
n_cols = 3  # Máximo de 3 columnas por fila

# Crear una figura grande para acomodar todos los subplots
plt.figure(figsize=(n_cols * 5, n_rows * 4))  # El tamaño puede ser ajustado

# Crear un loop para generar los kdeplots
for index, column in enumerate(columnas, 1):  # Iniciar el índice en 1 para el subplot
    plt.subplot(n_rows, n_cols, index)
    # Dibujar el kdeplot para la columna actual, ignorando NaNs
    # Seaborn automáticamente maneja NaNs con kdeplot
    sn.kdeplot(data=df[column], shade=True)
    plt.title(f'KDE de {column}')
    plt.xlabel(column)

# Ajustar el layout para evitar que los títulos se solapen
plt.tight_layout()

# Mostrar los gráficos
plt.show()

"""Este código generará un gráfico de estimación de densidad de kernel (kdeplot) para cada columna, lo cual es útil para ver la forma de la distribución de datos. Los gráficos KDE son una buena manera de ver la densidad de los puntos de datos, especialmente cuando tienes un gran conjunto de datos continuos."""

# Lista de todas las columnas para iterar
columnas = columnas = df.select_dtypes(include=[np.number]).columns

# Número de filas y columnas para la cuadrícula de subplots
n_rows = (len(columnas) + 2) // 3  # Asegurar que haya suficientes filas
n_cols = 3  # Máximo de 3 columnas por fila

# Crear una figura grande para acomodar todos los subplots
plt.figure(figsize=(n_cols * 5, n_rows * 4))  # El tamaño puede ser ajustado

# Crear un loop para generar los stripplots
for index, column in enumerate(columnas, 1):  # Iniciar el índice en 1 para el subplot
    plt.subplot(n_rows, n_cols, index)
    # Dibujar el stripplot para la columna actual
    sn.stripplot(x=df[column], alpha=0.5)
    plt.title(f'Stripplot de {column}')
    plt.xlabel(column)

# Ajustar el layout para evitar que los títulos se solapen
plt.tight_layout()

# Mostrar los gráficos
plt.show()

"""El histograma de puntos permite visualizar valores atípicos (outliers)"""

# Crear una nueva columna que solo contenga la hora del índice de fecha y hora
df['Hora'] = df.index.get_level_values('Fecha').hour

# Lista de todas las columnas numéricas para iterar (excluyendo la nueva columna 'Hora')
columnas_numericas = df.select_dtypes(include=['float64', 'int64']).columns.drop('Hora')

# Número de filas y columnas para la cuadrícula de subplots
n_rows = (len(columnas_numericas) + 2) // 3  # Asegurar que haya suficientes filas
n_cols = 3  # Máximo de 3 columnas por fila

# Crear una figura grande para acomodar todos los subplots
plt.figure(figsize=(n_cols * 6, n_rows * 4))  # El tamaño puede ser ajustado

# Crear un loop para generar los diagramas de caja y bigote
for index, column in enumerate(columnas_numericas, 1):  # Iniciar el índice en 1 para el subplot
    plt.subplot(n_rows, n_cols, index)
    # Dibujar el diagrama de caja y bigote
    sn.boxplot(x='Hora', y=column, data=df)
    plt.title(f'Diagrama de Caja de {column} vs. Hora')
    plt.xlabel('Hora del día')
    plt.ylabel(column)

# Ajustar el layout para evitar que los títulos y etiquetas se solapen
plt.tight_layout()

# Mostrar los gráficos
plt.show()

""" Los diagramas de caja y bigote se generarán para cada columna numérica con respecto a las horas del día, permitiéndote ver cómo se distribuyen los valores de las columnas en diferentes horas y detectar outliers."""

# Filtrar el DataFrame para el año 2023
df.drop('Hora', axis=1, inplace=True)
mask = df.index.get_level_values('Fecha').year == 2023
df_2023 = df[mask]

# Agrupar por día y calcular el promedio de cada columna numérica
# Aquí, asumimos que el nivel 'Fecha' ya está en formato adecuado para agrupar por día
df_2023_promedio_diario = df_2023.groupby(df_2023.index.get_level_values('Fecha').normalize()).mean()

# Lista de todas las columnas numéricas para iterar
columnas_numericas = df_2023_promedio_diario.select_dtypes(include=['float64', 'int64']).columns

# Número de filas para la cuadrícula de subplots. Una fila por cada columna numérica.
n_rows = len(columnas_numericas)

# Ajustes para la figura que contendrá todos los subplots
plt.figure(figsize=(15, n_rows * 5))  # Ajusta el tamaño según necesidad

# Crear un loop para generar los lineplots
for index, column in enumerate(columnas_numericas, 1):
    plt.subplot(n_rows, 1, index)
    sn.lineplot(x=df_2023_promedio_diario.index, y=df_2023_promedio_diario[column], marker='o', ci=None)
    plt.title(f'Promedio Diario de {column} en 2023')
    plt.xlabel('Fecha')
    plt.ylabel('Promedio de ' + column)
    # Rotar las fechas para mejorar la legibilidad
    plt.xticks(rotation=45)

# Ajustar el layout para evitar solapamientos
plt.tight_layout()

# Mostrar los gráficos
plt.show()

df

"""#Limpieza de Datos y Transformación

Afortunadamente no encontramos Inconsistencia en los datos.

##Filtrado

Este criterio consiste en descartar las variables muy concentradas dentro de la base de datos. Para esto calculamos la desviación estándar de las variables:
"""

df.drop(['Vertimiento'], axis=1, inplace=True)

df.std()

#df['generacion_potencial'] = df['Real'] + df['Vertimiento']
df_filtrado = df[df['Real'] > 0]  # Ajusta este umbral según sea necesario

df_filtrado.describe(include='all').round(1)

data= df_filtrado
data

"""##Imputación de valores perdidos"""

df_filtrado.isnull().sum()

# Visualización de la matriz de valores faltantes
msno.matrix(df_filtrado)

# Visualización del gráfico de barras de valores faltantes
msno.bar(df_filtrado)

# Porcentaje de valores faltantes por columna
porcentaje_faltantes = df_filtrado.isna().mean() * 100
print(porcentaje_faltantes.sort_values(ascending=False))

# Conteo de filas con valores faltantes
filas_con_faltantes = df_filtrado.isna().any(axis=1).sum()
print(f"Número de filas con al menos un valor faltante: {filas_con_faltantes}")

# Calcular el coeficiente de asimetría
pronosticos = ['Real', 'Externo', 'Coordinado', 'SExperto']
print(pronosticos)
for i in pronosticos:

  skewness = df_filtrado[i].skew()
  print(f"Coeficiente de Asimetría: {skewness}")

  # Interpretación del resultado
  if skewness > 0:
      print(f"La distribución de {i} tiene un sesgo positivo (hacia la derecha).")
  elif skewness < 0:
      print(f"La distribución de {i} tiene un sesgo negativo (hacia la izquierda).")
  else:
      print(f"La distribución de {i} es aproximadamente simétrica.")

sn.kdeplot(df_filtrado['Externo'])
plt.show()

df_filtrado

# Asumiendo que 'df_filtrado' ya está definido y contiene las columnas 'Fecha', 'Nombre', 'Externo', 'Coordinado', 'S.Experto'
#df_filtrado.set_index(['Fecha', 'Nombre'], inplace=True)

# Inicializar el KNNImputer
imputer = KNNImputer(n_neighbors=3)

# Columnas para imputar
columnas_para_imputar = ['Externo', 'Coordinado', 'SExperto']

# Realizar la transformación logarítmica a las columnas con sesgo
df_transformed = df_filtrado[columnas_para_imputar].applymap(lambda x: np.log1p(x) if x > 0 else x)

# 1. Mantener una copia de los datos originales antes de la imputación
df_original = df_filtrado[columnas_para_imputar].copy()

# Imputar los datos NaN usando KNN en el DataFrame transformado
df_imputed_log = pd.DataFrame(imputer.fit_transform(df_transformed), columns=columnas_para_imputar, index=df_transformed.index)

# Revertir la transformación logarítmica
df_imputed = df_imputed_log.apply(np.expm1)

# Añadir ruido aleatorio solo a las filas imputadas para conservar la varianza original de las columnas
for columna in columnas_para_imputar:
    std_original = df_filtrado[columna].std(skipna=True)
    std_imputed = df_imputed[columna].std()
    std_diff = std_original - std_imputed if std_original > std_imputed else 0

    rows_to_adjust = df_filtrado[columna].isna()
    random_noise = np.random.normal(0, std_diff, size=rows_to_adjust.sum())
    df_imputed.loc[rows_to_adjust, columna] += random_noise

# 2. Combinar los valores originales y los imputados
for columna in columnas_para_imputar:
    df_filtrado[f'{columna}_Original'] = df_original[columna]
    df_filtrado[f'{columna}_Imputada'] = df_imputed[columna]

# Resetear el índice para volver a la forma original
df_filtrado.reset_index(inplace=True)

# Graficar las distribuciones antes y después de la imputación
plt.figure(figsize=(18, 6))
for i, columna in enumerate(columnas_para_imputar, 1):
    plt.subplot(1, len(columnas_para_imputar), i)
    sn.kdeplot(df_filtrado[f'{columna}_Original'].dropna(), label=f'{columna} Original')
    sn.kdeplot(df_filtrado[f'{columna}_Imputada'], label=f'{columna} Imputada')
    plt.legend()
plt.tight_layout()
plt.show()

df_filtrado
#df_filtrado[df_filtrado['Externo'].isna()]

df_filtrado.drop(['Externo','Coordinado','S.Experto','Externo_Original','Coordinado_Original','S.Experto_Original'], axis=1, inplace=True)
df_filtrado.describe(include='all').round(1)

df_filtrado

df_filtrado.isnull().sum()

"""#Cálculo MAE y RMSE"""

df['Fecha'] = pd.to_datetime(df['Fecha'])
df['generacion_potencial'] = df['Real'] + df['Vertimiento']
df['Fecha_Hora'] = df['Fecha'].dt.floor('H')
df['Fecha_Dia'] = df['Fecha'].dt.date

# Lista de pronósticos para iterar
pronosticos = ['Externo', 'Coordinado', 'S.Experto']

# Funciones para calcular MAE y RMSE
def mae_vectorizado(y_true, y_pred):
    return np.mean(np.abs(y_true - y_pred))

def rmse_vectorizado(y_true, y_pred):
    return np.sqrt(np.mean((y_true - y_pred) ** 2))

# Inicializar listas de resultados
resultados_horarios = []
resultados_diarios = []

# Realizar cálculos
for pronostico in pronosticos:
    # Calcular diferencias para MAE y cuadrados de diferencias para RMSE
    df['diff'] = np.abs(df['generacion_potencial'] - df[pronostico])  # Para MAE
    df['diff_squared'] = (df['generacion_potencial'] - df[pronostico]) ** 2  # Para RMSE

    # Agrupar por hora para calcular MAE y RMSE horarios
    horario_agg = df.groupby(['Nombre', 'Fecha_Hora']).agg(MAE_H=('diff', 'mean'), RMSE_H=('diff_squared', 'mean')).reset_index()
    horario_agg['RMSE_H'] = np.sqrt(horario_agg['RMSE_H'])  # Aplicar raíz cuadrada para RMSE
    horario_agg['Pronostico'] = pronostico
    resultados_horarios.append(horario_agg)

    # Agrupar por día para calcular MAE y RMSE diarios
    diario_agg = df.groupby(['Nombre', 'Fecha_Dia']).agg(MAE_D=('diff', 'mean'), RMSE_D=('diff_squared', 'mean')).reset_index()
    diario_agg['RMSE_D'] = np.sqrt(diario_agg['RMSE_D'])  # Aplicar raíz cuadrada para RMSE
    diario_agg['Pronostico'] = pronostico
    resultados_diarios.append(diario_agg)

# Concatenar resultados en DataFrames
resultados_horarios_df = pd.concat(resultados_horarios, ignore_index=True)
resultados_diarios_df = pd.concat(resultados_diarios, ignore_index=True)

# Limpiar el DataFrame original para quitar las columnas temporales
df.drop(columns=['diff', 'diff_squared'], inplace=True)

# Mostrar resultados
print("Resultados Horarios:")
print(resultados_horarios_df.head())
print("\nResultados Diarios:")
print(resultados_diarios_df.head())

resultados_ordenados_df = resultados_horarios_df.sort_values(by=['Nombre', 'Fecha_Hora'])
resultados_ordenados_df

resultados_ordenados_df = resultados_diarios_df.sort_values(by=['Nombre', 'Fecha_Dia'])
resultados_ordenados_df

resultados_df['Nombre'].unique()

central_especifica = 'PFV GUANCHOI'  # Cambia esto por el nombre de tu central
df_central = resultados_df[resultados_df['Nombre'] == central_especifica]

plt.figure(figsize=(10, 6))
sn.lineplot(data=df_central, x='Fecha', y='MAE', hue='pronostico')
plt.title(f'MAE a lo Largo del Tiempo para {central_especifica}')
plt.xticks(rotation=45)
plt.show()

# Calcular el MAE/RMSE promedio por central y pronóstico
heatmap_data = resultados_df.groupby(['Nombre', 'pronostico'])['MAE'].mean().unstack()

plt.figure(figsize=(15, 18))
sn.heatmap(heatmap_data, annot=True, cmap="coolwarm")
plt.title('MAE Promedio por Central y Pronóstico')
plt.xticks(rotation=45)
plt.show()

plt.figure(figsize=(10, 6))
sn.boxplot(data=resultados_df, x='pronostico', y='MAE')
plt.title('Distribución del MAE por Tipo de Pronóstico')
plt.xticks(rotation=45)
plt.show()

plt.figure(figsize=(10, 6))
sn.scatterplot(data=resultados_df, x='MAE', y='RMSE', hue='pronostico')
plt.title('MAE vs. RMSE por Tipo de Pronóstico')
plt.show()

# Extraer la hora de la columna 'fecha_hora'
resultados_df['hora'] = resultados_df['Fecha'].dt.hour

# Ahora, vamos a crear un boxplot del MAE para cada hora
plt.figure(figsize=(12, 8))
sn.boxplot(data=resultados_df, x='hora', y='MAE')
plt.title('Distribución del MAE por Hora del Día')
plt.xlabel('Hora del Día')
plt.ylabel('MAE')
plt.xticks(rotation=45)  # Rotar las etiquetas del eje X para mejor legibilidad

plt.show()

plt.figure(figsize=(14, 7))
sn.lineplot(data=resultados_df, x='Fecha', y='MAE', hue='pronostico', marker='o')
plt.title('MAE a lo Largo del Tiempo')
plt.xlabel('Fecha y Hora')
plt.ylabel('MAE')
plt.xticks(rotation=45)  # Rotar las etiquetas de fecha para mejor legibilidad

plt.show()

tipos_pronostico = ['Externo', 'Coordinado', 'S.Experto']

# Crear figura y ejes para los subplots
fig, axes = plt.subplots(nrows=1, ncols=3, figsize=(18, 6), sharey=True)

for ax, pronostico in zip(axes, tipos_pronostico):
    # Filtrar el DataFrame por tipo de pronóstico
    df_filtrado = resultados_df[resultados_df['pronostico'] == pronostico]

    # Crear el boxplot para el MAE por hora para el pronóstico actual
    sn.boxplot(data=df_filtrado, x='hora', y='MAE', ax=ax)
    ax.set_title(f'MAE por Hora - {pronostico}')
    ax.set_xlabel('Hora del Día')
    ax.set_ylabel('MAE')
    ax.tick_params(axis='x', rotation=45)

# Ajustar el layout para evitar la superposición
plt.tight_layout()

# Mostrar el gráfico
plt.show()

df = Pronosticos
df
# Calcular la generación potencial total (generación real + vertimiento)
df['generacion_potencial'] = df['Real'] + df['Vertimiento']
# Función para calcular MAE
def calcular_mae(real, pronostico):
    return np.mean(np.abs(real - pronostico))

# Función para calcular RMSE
def calcular_rmse(real, pronostico):
    return np.sqrt(np.mean((real - pronostico) ** 2))

# Calcular MAE y RMSE para cada central y cada tipo de pronóstico
resultados = []

for central in df['Nombre'].unique():
    central_data = df[df['Nombre'] == central]
    for pronostico in ['Externo', 'Coordinado', 'S.Experto']:
        mae = calcular_mae(central_data['generacion_potencial'], central_data[pronostico])
        rmse = calcular_rmse(central_data['generacion_potencial'], central_data[pronostico])
        resultados.append({'Central': central, 'Pronostico': pronostico, 'MAE': mae, 'RMSE': rmse})

# Convertir los resultados en un DataFrame
resultados_x_central = pd.DataFrame(resultados)

# Mostrar los resultados
print(resultados_x_central)

resultados_df

sn.set(style="whitegrid")

# Crear una figura y un conjunto de subgráficos
fig, ax = plt.subplots(2, 1, figsize=(12, 10))

# Gráfico de barras para MAE
sn.barplot(x='Pronostico', y='MAE', data=resultados_df, ax=ax[0])
ax[0].set_title('MAE por Tipo de Pronóstico')

# Gráfico de barras para RMSE
sn.barplot(x='Pronostico', y='RMSE', data=resultados_df, ax=ax[1])
ax[1].set_title('RMSE por Tipo de Pronóstico')

# Mostrar la figura
plt.tight_layout()
plt.show()

# Boxplot para MAE
plt.figure(figsize=(12, 6))
sn.boxplot(x='Central', y='MAE', data=resultados_df)
plt.title('Distribución del MAE por Central')
plt.xticks(rotation=45)  # Rotar los nombres de las centrales si son demasiado largos
plt.show()

# Boxplot para RMSE
plt.figure(figsize=(12, 6))
sn.boxplot(x='Central', y='RMSE', data=resultados_df)
plt.title('Distribución del RMSE por Central')
plt.xticks(rotation=45)
plt.show()

# Asegúrate de que 'fecha_hora' es de tipo datetime
resultados_df['Fecha'] = pd.to_datetime(resultados_df['fecha_hora'])

# Ordenar el DataFrame por fecha_hora
resultados_df.sort_values('fecha_hora', inplace=True)

# Gráfico de líneas para MAE
plt.figure(figsize=(12, 6))
sns.lineplot(x='fecha_hora', y='MAE', hue='Central', data=resultados_df, marker='o')
plt.title('MAE a lo Largo del Tiempo por Central')
plt.xticks(rotation=45)
plt.show()

# Gráfico de líneas para RMSE
plt.figure(figsize=(12, 6))
sns.lineplot(x='fecha_hora', y='RMSE', hue='Central', data=resultados_df, marker='o')
plt.title('RMSE a lo Largo del Tiempo por Central')
plt.xticks(rotation=45)
plt.show()

"""#Analisis Exploratorio"""

n_cols = data.shape[1]
n_cols

# Lista de columnas a omitir
columnas_omitir = ['Nombre', 'Fecha']

# Filtrar las columnas para excluir las columnas categóricas
columnas_para_graficar = [col for col in data.columns if col not in columnas_omitir]

# Número de columnas a graficar
n_cols = len(columnas_para_graficar)

# Calcular el número de filas necesarias (hasta 3 columnas por fila)
n_rows = (n_cols + 2) // 3  # Se suma 2 para asegurar el redondeo hacia arriba en caso de que n_cols no sea múltiplo de 3

# Crear figura y ejes para los subplots
fig, axes = plt.subplots(n_rows, 3, figsize=(15, 4 * n_rows))  # 3 columnas por fila y ajuste del tamaño

# Aplanar el array de ejes si hay más de una fila
axes = axes.flatten()

# Iterar sobre las columnas filtradas y crear un KDE para cada una
for i, col in enumerate(columnas_para_graficar):
    sn.kdeplot(data[col], ax=axes[i], shade=True)
    axes[i].set_title(col)

# Ocultar los ejes no utilizados si no hay suficientes gráficos para llenar la última fila
for j in range(i + 1, len(axes)):
    axes[j].set_visible(False)

plt.tight_layout()  # Ajustar automáticamente los parámetros de la subtrama
plt.show()

data

data_oct = data[data.index.month == 9 ]
data_oct

# Descomposición de una de las series

result = seasonal_decompose(data['Real'], model='additive', period=24)  # Usando un periodo de 24 para capturar la estacionalidad diaria
# Definiendo el tamaño de la figura para una visualización más clara
plt.figure(figsize=(14, 10), dpi=80)

# Trazando la tendencia
plt.subplot(411)
plt.plot(result.trend)
plt.title('Tendencia')
plt.xticks(rotation=45)

# Trazando la estacionalidad
plt.subplot(412)
plt.plot(result.seasonal)
plt.title('Estacionalidad')
plt.xticks(rotation=45)

# Trazando los residuos
plt.subplot(413)
plt.plot(result.resid)
plt.title('Residuos')
plt.xticks(rotation=45)

# Trazando la observación real
plt.subplot(414)
plt.plot(result.observed)
plt.title('Real (Observado)')
plt.xticks(rotation=45)

# Mejoramos las etiquetas del eje x para mostrar los meses y años.
plt.gca().xaxis.set_major_locator(mdates.MonthLocator())
plt.gca().xaxis.set_major_formatter(mdates.DateFormatter('%b %Y'))

# Ajustamos el layout y la orientación de las etiquetas.
plt.tight_layout()
plt.gcf().autofmt_xdate()

# Mostramos la figura.
plt.show()



sn.lineplot(data=df)
plt.title('Pronósticos de Generación de Energía Solar')
plt.ylabel('Generación (Unidades)')
plt.xlabel('Fecha')
plt.xticks(rotation=45)
plt.show()

# Asumiendo que df es tu DataFrame y tiene columnas 'S.Experto', 'Columna2', y 'Columna3' que quieres comparar
df_melted = pd.melt(df, value_vars=['Real','Externo', 'Coordinado', 'S.Experto'], var_name='Columna', value_name='Valor')
sn.stripplot(x='Columna', y='Valor', data=df_melted, dodge=True)
plt.show()

"""#Calculo de los errores"""

# Calculamos el error absoluto y el error relativo
errores = pd.DataFrame()
errores['Nombre'] = pronosticos['Nombre']
errores['Fecha'] = pronosticos['Fecha']
errores['error_absoluto_externo'] = (df['Externo'] - df['Real']).abs()
errores['error_relativo_externo'] = errores['error_absoluto_externo'] / df['Real']
errores['error_absoluto_coordinado'] = (df['Coordinado'] - df['Real']).abs()
errores['error_relativo_coordinado'] = errores['error_absoluto_coordinado'] / df['Real']
errores['error_absoluto_Sexperto'] = (df['S.Experto'] - df['Real']).abs()
errores['error_relativo_Sexperto'] = errores['error_absoluto_Sexperto'] / df['Real']

errores
Pronosticos

errores.to_excel('/content/drive/MyDrive/CEN/errores_Solar.xlsx', index=False, engine='openpyxl')

Pronosticos.to_excel('/content/drive/MyDrive/CEN/pronosticos_Solar.xlsx', index=False, engine='openpyxl')

data = errores

sn.set(style="whitegrid")

# Análisis Descriptivo
descripcion = data['error_absoluto_externo'].describe()

# Preparación para análisis temporal y por hora del día
data['Fecha'] = pd.to_datetime(data['Fecha'])  # Asegurar que 'Fecha' es datetime
data['Hora'] = data['Fecha'].dt.hour  # Extraer hora del día

# Análisis Temporal: Visualización de los valores pronosticados a lo largo del tiempo
plt.figure(figsize=(14, 7))
plt.plot(data['Fecha'], data['error_absoluto_externo'], label='Valor Pronosticado error_absoluto_externo', color='darkorange')
plt.title('error_absoluto_externo Generación Solar S.Externo a lo Largo del Tiempo')
plt.xlabel('Fecha')
plt.ylabel('Valor error_absoluto_externo')
plt.xticks(rotation=45)
plt.tight_layout()
plt.legend()
plt.show()

# Análisis por Hora del Día
plt.figure(figsize=(10, 6))
sn.boxplot(x='Hora', y='error_absoluto_externo', data=data, palette="coolwarm")
plt.title('Distribución de error_absoluto_externo por Hora del Día')
plt.xlabel('Hora del Día')
plt.ylabel('Valor error_absoluto_externo')
plt.tight_layout()

sn.set(style="whitegrid")

# Análisis Descriptivo
descripcion = data['error_absoluto_externo'].describe()

# Preparación para análisis temporal y por hora del día
data['Fecha'] = pd.to_datetime(data['Fecha'])  # Asegurar que 'Fecha' es datetime
data['Hora'] = data['Fecha'].dt.hour  # Extraer hora del día

# Análisis Temporal: Visualización de los valores pronosticados a lo largo del tiempo
plt.figure(figsize=(14, 7))
plt.plot(data['Fecha'], data['error_absoluto_coordinado'], label='Valor Pronosticado error_absoluto_coordinado', color='darkorange')
plt.title('error_absoluto_externo Generación Solar S.Externo a lo Largo del Tiempo')
plt.xlabel('Fecha')
plt.ylabel('Valor error_absoluto_coordinado')
plt.xticks(rotation=45)
plt.tight_layout()
plt.legend()
plt.show()

# Análisis por Hora del Día
plt.figure(figsize=(10, 6))
sn.boxplot(x='Hora', y='error_absoluto_coordinado', data=data, palette="coolwarm")
plt.title('Distribución de error_absoluto_coordinado por Hora del Día')
plt.xlabel('Hora del Día')
plt.ylabel('Valor error_absoluto_coordinado')
plt.tight_layout()

sn.set(style="whitegrid")

# Análisis Descriptivo
descripcion = data['error_absoluto_externo'].describe()

# Preparación para análisis temporal y por hora del día
data['Fecha'] = pd.to_datetime(data['Fecha'])  # Asegurar que 'Fecha' es datetime
data['Hora'] = data['Fecha'].dt.hour  # Extraer hora del día

# Análisis Temporal: Visualización de los valores pronosticados a lo largo del tiempo
plt.figure(figsize=(14, 7))
plt.plot(data['Fecha'], data['error_absoluto_externo'], label='Valor Pronosticado error_absoluto_externo', color='darkorange')
plt.title('error_absoluto_externo Generación Solar S.Externo a lo Largo del Tiempo')
plt.xlabel('Fecha')
plt.ylabel('Valor error_absoluto_externo')
plt.xticks(rotation=45)
plt.tight_layout()
plt.legend()
plt.show()

# Análisis por Hora del Día
plt.figure(figsize=(10, 6))
sn.boxplot(x='Hora', y='error_absoluto_externo', data=data, palette="coolwarm")
plt.title('Distribución de error_absoluto_externo por Hora del Día')
plt.xlabel('Hora del Día')
plt.ylabel('Valor error_absoluto_externo')
plt.tight_layout()

"""#Preprocesamiento"""

# Definir los intervalos en los que quieres subdividir los valores
bins = [0, 25, 50, 75, 100 ,125, 150, 175, 200, 225, 250, 275, 300]  # Puedes ajustar los intervalos según tus necesidades

# Crear una nueva columna en el DataFrame que contenga las categorías de los intervalos
df['Valor_intervalo'] = pd.cut(df['Valor'], bins=bins)

# Contar las ocurrencias de cada intervalo
valor_counts = df['Valor_intervalo'].value_counts().sort_index()

# Crear el gráfico de barras
valor_counts.plot.bar(figsize=(10, 6))
plt.xlabel('Intervalo de Valor')
plt.ylabel('Frecuencia')
plt.title('Histograma de Valores subdivididos en intervalos')
plt.show()

# Supongamos que tienes un DataFrame llamado df y una columna 'Hora' que contiene datos de horas, y una columna 'Valor' con los valores asociados

# Crear el gráfico de barras
plt.figure(figsize=(12, 6))
plt.bar(df['Hora'], df['Valor'])

# Agregar etiquetas y título
plt.xlabel('Hora')
plt.ylabel('Valor')
plt.title('Valores en función de la hora del día')

# Rotar etiquetas del eje x para una mejor legibilidad
plt.xticks(rotation=45)

# Mostrar el gráfico
plt.show()

promedio_x_hr = df.groupby(df['Hora'])['Valor'].mean()
# Crear el gráfico de barras
plt.figure(figsize=(12, 6))
plt.bar(promedio_x_hr.index, promedio_x_hr)

# Agregar etiquetas y título
plt.xlabel('Hora del día')
plt.ylabel('Promedio del valor')
plt.title('Promedio del valor por hora del día')

# Mostrar el gráfico
plt.show()
print(promedio_x_hr)

horas_a_eliminar = [1, 2, 3, 4, 5, 6, 23, 24]
df = df[~df['Hora'].isin(horas_a_eliminar)]

df.describe(include='all').round(1)

mean_demand = df['Valor'].mean()
std_demand = df['Valor'].std()
threshold = 6 * std_demand
outliers_mask = np.abs(df['Valor'] - mean_demand) > threshold
df_no_outliers = df[~outliers_mask]

plt.figure(figsize=(10, 6))
plt.plot(df['Valor'], label='Original Data')
plt.plot(df_no_outliers['Valor'], label='Data without Outliers', linestyle='--')
plt.xlabel('Time')
plt.ylabel('Electrical Demand')
plt.title('Handling Outliers in Electrical Demand Time Series')
plt.legend()
plt.show()

dff = df_no_outliers

# Calcula el rango intercuartil (IQR)
Q1 = df['Valor'].quantile(0.25)
Q3 = df['Valor'].quantile(0.75)
IQR = Q3 - Q1

# Define los límites inferior y superior para detectar outliers
limite_inferior = Q1 - 1.5 * IQR
limite_superior = Q3 + 6 * IQR

# Identifica y cuenta los outliers
outliers = df[(df['Valor'] < limite_inferior) | (df['Valor'] > limite_superior)]
num_outliers = len(outliers)

# Visualiza el diagrama de caja y bigotes
plt.figure(figsize=(8, 6))
plt.boxplot(df['Valor'], vert=False)
plt.title('Diagrama de Caja y Bigotes')
plt.xlabel('Valor')
plt.ylabel('Datos')
plt.grid(True)
plt.show()

plt.figure(figsize=(8, 6))
plt.boxplot(dff['Valor'], vert=False)
plt.title('Diagrama de Caja y Bigotes sin outliers')
plt.xlabel('Valor')
plt.ylabel('Datos')
plt.grid(True)
plt.show()

# Imprime el número de outliers detectados y los valores de los límites
print("Número de outliers:", num_outliers)
print("Límite inferior:", limite_inferior)
print("Límite superior:", limite_superior)

# Obtener los datos de la columna 'Valor' como un arreglo numpy
data = df['Valor'].values

# Ajustar una distribución exponencial a los datos observados
params = stats.expon.fit(data)

# Calcular la distribución teórica basada en los parámetros ajustados
expon_dist = stats.expon(*params)

# Realizar el test de bondad de ajuste (KS test)
ks_statistic, p_value = stats.kstest(data, expon_dist.cdf)

# Imprimir los resultados del test
print(f"KS statistic: {ks_statistic}")
print(f"p-value: {p_value:.10f}")

# Graficar el histograma de los datos observados y la distribución teórica ajustada
plt.hist(data, bins=30, density=True, alpha=0.5, label='Datos observados')
x = np.linspace(0, np.max(data), 100)
plt.plot(x, expon_dist.pdf(x), 'r-', lw=2, label='Distribución exponencial ajustada')
plt.xlabel('Valor')
plt.ylabel('Densidad de probabilidad')
plt.title('Test de bondad de ajuste para distribución exponencial')
plt.legend()
plt.show()

#Histograma de puntos para ver outliers con más claridad
sn.stripplot(x='Valor', data=df)
plt.show()

"""Este código tomará el DataFrame df y pivotará los datos de manera que cada fila represente una hora y cada columna represente una central de energía solar, con los valores de generación de energía en cada celda."""

# Pivota el DataFrame
pivot_df = merged_df.pivot_table(index=['Fecha', 'Hora'], columns='Nombre', values='Valor', aggfunc='sum')

# Imprime el DataFrame pivoteado
pivot_df